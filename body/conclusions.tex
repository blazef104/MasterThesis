% !TEX root = ../main.tex
\chapter{Conclusions and Future Works}
\label{chap:6}

\section{Conclusions}

As illustrated in the previous chapters, with this thesis we demonstrated how it is possible to use different techniques in order to write custom PANDA plugins to handle evasive patterns that malware analysts meet in their daily practice.

This proven to be a particularly challenging in PANDA compared to other analysis techniques. As a matter of fact, although the fine grained control available with this framework is particularly powerful on the analysis side, it poses different challenges when it comes to expanding the framework. Classical function hooking is performed by the use of a detour sequences in order to redirect the execution when a certain point is reached. This can be performed in different ways. For example it might be possible to replace on disk a certain library with another one having an hooking mechanism in place or such mechanism can be dynamically inserted in memory at run time. In the PANDA framework this is handled in a different way, detours can be placed at translation level, making this mechanism more stealthy but at the same time more complex as some of the context might be missed. Moreover, while dynamic binary instrumentation works at process level PANDA gives control at system level. It is therefore necessary to handle Operating System internal objects and structures ``from the outside'', without any code running on the machine and by directly accessing memory and registers. Moreover, while usually instrumentation takes place at process level, meaning that some detour sequences are added in the binary code this in PANDA takes place at system level therefore making it harder to control and react.

%\daniele{Remind the reader why this is harder than in other solutions such as dynamic binary instrumentation, since here you are controlling the entire system and you have to interpose on OS primitives and internals at system level instead of process level etc}  

The newly introduced plugins can be used to selectively modify the environment at run time and by targeting only a user defined executable. In this way only the defined sample will receive the patched results while the rest of the system will remain untouched. This has two main benefits, the first one is that patching happens only when needed therefore avoiding to introduce an excessive overhead in the system. The second one is that since no other component of the system is patched the system will not be affected by the modifications which might render it unstable in the long run. As a matter of fact, many of the functions used by malware are used also internally by windows. If the TSC counter is arbitrarly patched to always return a custom and fixed value this might crash the system. In the same way the Operating System or other software might need to know the real capabilities of the underlaying hardware by using CPUID or system calls. Blindly patching them might render the system unstable and unusable. 

%\daniele{I did not understand the very first sentence on ``very specific sample'', I guess we will get back to this tomorrow}.

\section{Future Works}

The newly presented system will be transparent for the evasive queries of the malware instance under analysis, therefore different analysis techniques can be implemented on top of it. The PANDA repository already provides some plugins for basic analysis. Some for basic taint analysis are available such as serial taint, tainted memory I/O and file taint. Other plugins are available for coverage analysis, network traffic inspection, statistic of function calls and similar. Plugins aiming also at extending static analysis. An example is the \textit{ida\_taint2} plugin which aims at integrating some taint analysis results into IDA Pro. Moreover, there are some plugins that are available only for the ARM architecture as this is becoming increasingly common and allows also for IoT malware analysis. 

A future area of development of this system would be the integration with taint analysis. As a matter of fact PANDA provides in the official repository a plugin dedicated to this kind of analysis, \textit{taint2}. 

Using such plugin it would be possible to create another one to trace how common red pills are handled inside the malware, in this way it would be possible to see how memory regions, strings and functions are treated internally. This can further aid the analyst in detecting functions needs to be patched. As a matter of fact, determining and tracking which data makes the malware reach an exiting primitive will suggest how to change or hide that data. 

Similarly dynamic backward slicing can be employed to track where a data is coming from. This is the reverse of the previous process where, having a given value, the user is able to trace back in the program which functions are involved in generating such value. This is provided by PANDA with the \textit{dynslice} tool\footnote{\url{https://github.com/panda-re/panda/blob/7e266b57708ad04c2adad272bd57bbe752cefce9/panda/docs/dynslice.md}}.

These last two techniques can also be combined together to aid the analyst in automatically determining which red pills are employed by that specific malware and manually patching them. Moreover, by using the python interface of panda and the plugins developed in this thesis it would be possible to create an new analysis environment. With the automation provided by python, the visibility provided by taint and dynamic slicing and the patching capabilities provided by our plugins the system will be capable of automatically run a malware sample, collect possible red pills, create a patching mechanism and repeat until the sample reaches a successful execution.  

In addition to this, as previously mentioned, even with the developed plugins the system is still failing to pass WMI related tests. WMI or Windows Management Instrumentation is an operating system interface exposed by Windows that allows programs to manage the Operating System both locally and remotely. The purpose of WMI allow for management information to be shared between different applications. In particular this interface implements an SQL like language to perform OS queries.

This interface can be used to retrieve information from the underlying operating system. Due to the fact that it does not relay on system calls or API calls this behaviour would not be caught by the developed plugins. Instead, it is necessary to develop a custom plugin that will take care of hooking specific parts of the WMI handling part inside the Operating System and can therefore provide patched results. 

%\daniele{Add that it would be interesting to explore techniques like taint analysis or dynamic backward slicing to track how malware reaches exiting primitives and provide hints to the analyst on what may require patching. See what plugins are available for panda}

Lastly, there are some particular family of malware that will fingerprint the system searching for specific red pills. In particular such samples attempts to determine if a system is freshly installed or not as this is often the indicator of an analysis environment. For this reason they prefer to infect a ``dirty'' system and avoid the ones in a pristine state. This is also the reason why some sandboxes have common programs pre-installed into the default system.

To counter this malware strain it would be necessary to write a custom plugin, based on the API and syscall hook plugins developed in this thesis. This new plugin will need to intercept these specific fingerprinting techniques and patch the functions responsible to provide the results. In this way the malware will be tricked into thinking that the system is an actively used one and it is worth being infected. 